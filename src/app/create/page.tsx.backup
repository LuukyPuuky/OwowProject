"use client";
import { useState, useCallback, useEffect, useRef } from "react";
import { Sidebar } from "@/components/sidebar";
import { PixelCanvas } from "@/components/pixel-canvas";
import { TopBar as Header } from "@/components/top-bar";
import LatestAnimations from "@/components/latest-animations";
import { Modal } from "@/components/ui/modal";
import { CANVAS_WIDTH, CANVAS_HEIGHT } from "@/lib/canvas";
import type { Frame, BrushMode, BrushShape, Tool } from "@/lib/types";
import { animations } from "@/lib/animations";
import { EditorToolbar, EditorTimeline } from "@/features/editor/_components";

export default function CreatePage() {
  const [isSidebarCollapsed, setIsSidebarCollapsed] = useState(false);
  const favorites = new Set<string>();

  // Custom animations state for sidebar preview
  const [customAnimations, setCustomAnimations] = useState<Array<{
    id: string;
    name: string;
    frames: Array<{ dur: number; arr: boolean[] }>;
    createdAt: string;
    status: string;
  }>>([]);
  const [equippedId, setEquippedId] = useState<string>("logo");

  // Frame & Animation State
  const [frames, setFrames] = useState<Frame[]>([
    { dur: 1000, arr: new Array(CANVAS_WIDTH * CANVAS_HEIGHT).fill(false) }
  ]);
  const [currentFrameIndex, setCurrentFrameIndex] = useState(0);
  const [playing, setPlaying] = useState(false);
  const playTimerRef = useRef<NodeJS.Timeout | null>(null);
  const framesRef = useRef(frames);
  
  useEffect(() => {
    framesRef.current = frames;
  }, [frames]);
  
  const [workingPixels, setWorkingPixels] = useState<boolean[]>(
    new Array(CANVAS_WIDTH * CANVAS_HEIGHT).fill(false)
  );

  // Drawing State
  const [activeTool, setActiveTool] = useState<Tool>('brush');
  const [brushMode, setBrushMode] = useState<BrushMode>('paint');
  const [brushShape, setBrushShape] = useState<BrushShape>('circle');
  const [brushSize, setBrushSize] = useState(2);
  const [onionEnabled, setOnionEnabled] = useState(false);

  // Selection & Clipboard State
  const [selection, setSelection] = useState<{ startX: number; startY: number; endX: number; endY: number } | null>(null);
  const [clipboard, setClipboard] = useState<{ width: number; height: number; pixels: boolean[] } | null>(null);
  const [isSelecting, setIsSelecting] = useState(false);

  // Project State
  const [projectName, setProjectName] = useState("Untitled");
  const [frameDurationSeconds, setFrameDurationSeconds] = useState(1);
  const [lastSavedState, setLastSavedState] = useState<string>("");
  const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);

  // History
  const [history, setHistory] = useState<Frame[][]>([]);
  const [historyIndex, setHistoryIndex] = useState(-1);

  // Modal State
  const [modalConfig, setModalConfig] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
    type: "alert" | "confirm";
    onConfirm?: () => void;
    confirmText?: string;
    cancelText?: string;
    showDontShowAgain?: boolean;
    dialogId?: string;
  }>({
    isOpen: false,
    title: "",
    message: "",
    type: "alert",
  });

  // Track which dialogs should be skipped
  const [skipDialogs, setSkipDialogs] = useState<Set<string>>(() => {
    if (typeof window !== 'undefined') {
      const saved = localStorage.getItem('skipDialogs');
      return saved ? new Set(JSON.parse(saved)) : new Set();
    }
    return new Set();
  });

  const showAlert = useCallback((title: string, message: string) => {
    setModalConfig({
      isOpen: true,
      title,
      message,
      type: "alert",
    });
  }, []);

  const showConfirm = useCallback((title: string, message: string, onConfirm: () => void, dialogId?: string) => {
    // Check if this dialog should be skipped
    if (dialogId && skipDialogs.has(dialogId)) {
      onConfirm();
      return;
    }

    setModalConfig({
      isOpen: true,
      title,
      message,
      type: "confirm",
      onConfirm,
      showDontShowAgain: !!dialogId,
      dialogId,
    });
  }, [skipDialogs]);

  const closeModal = useCallback(() => {
    setModalConfig((prev) => ({ ...prev, isOpen: false }));
  }, []);

  const handleDontShowAgain = useCallback((checked: boolean) => {
    if (checked && modalConfig.dialogId) {
      const newSkipDialogs = new Set(skipDialogs);
      newSkipDialogs.add(modalConfig.dialogId);
      setSkipDialogs(newSkipDialogs);
      localStorage.setItem('skipDialogs', JSON.stringify([...newSkipDialogs]));
    }
  }, [modalConfig.dialogId, skipDialogs]);

  // Timeline scroll
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const [canScrollLeft, setCanScrollLeft] = useState(false);
  const [canScrollRight, setCanScrollRight] = useState(false);

  const checkScroll = () => {
    if (scrollContainerRef.current) {
      const { scrollLeft, scrollWidth, clientWidth } = scrollContainerRef.current;
      setCanScrollLeft(scrollLeft > 0);
      setCanScrollRight(scrollLeft < scrollWidth - clientWidth - 10);
    }
  };

  useEffect(() => {
    checkScroll();
    const container = scrollContainerRef.current;
    if (container) {
      container.addEventListener('scroll', checkScroll);
      window.addEventListener('resize', checkScroll);
    }
    return () => {
      container?.removeEventListener('scroll', checkScroll);
      window.removeEventListener('resize', checkScroll);
    };
  }, [frames.length]);

  // Load custom animations and equipped animation for sidebar preview
  useEffect(() => {
    const loadData = () => {
      try {
        // Load custom animations
        const saved = localStorage.getItem('customAnimations');
        if (saved) {
          setCustomAnimations(JSON.parse(saved));
        }
        
        // Load equipped animation ID
        const savedEquipped = localStorage.getItem('equippedAnimationId');
        if (savedEquipped) {
          setEquippedId(savedEquipped);
        }
      } catch (error) {
        console.error('Failed to load data:', error);
      }
    };
    
    loadData();
    
    // Listen for changes
    const handleStorageChange = () => {
      loadData();
    };
    
    window.addEventListener('storage', handleStorageChange);
    window.addEventListener('customAnimationsUpdated', handleStorageChange);
    
    return () => {
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('customAnimationsUpdated', handleStorageChange);
    };
  }, []);

  // Track changes to detect unsaved work
  useEffect(() => {
    const currentState = JSON.stringify({ frames, projectName });
    if (lastSavedState === "") {
      // Initial state - no changes yet
      setLastSavedState(currentState);
      setHasUnsavedChanges(false);
    } else {
      setHasUnsavedChanges(currentState !== lastSavedState);
    }
  }, [frames, projectName, lastSavedState]);

  const scroll = (direction: 'left' | 'right') => {
    if (scrollContainerRef.current) {
      const scrollAmount = 300;
      scrollContainerRef.current.scrollBy({
        left: direction === 'left' ? -scrollAmount : scrollAmount,
        behavior: 'smooth',
      });
      setTimeout(checkScroll, 100);
    }
  };

  const pushHistory = useCallback(() => {
    const newHistory = history.slice(0, historyIndex + 1);
    newHistory.push(JSON.parse(JSON.stringify(frames)));
    if (newHistory.length > 50) newHistory.shift();
    setHistory(newHistory);
    setHistoryIndex(newHistory.length - 1);
  }, [frames, history, historyIndex]);

  const saveWorkingPixelsToFrame = useCallback(() => {
    setFrames(prevFrames => {
      const newFrames = [...prevFrames];
      newFrames[currentFrameIndex] = { ...newFrames[currentFrameIndex], arr: [...workingPixels] };
      return newFrames;
    });
  }, [currentFrameIndex, workingPixels]);

  useEffect(() => {
    if (playing) return;
    setWorkingPixels([...framesRef.current[currentFrameIndex].arr]);
    setFrameDurationSeconds(framesRef.current[currentFrameIndex].dur / 1000);
  }, [currentFrameIndex, playing]);

  useEffect(() => {
    if (playing) return;
    
    const timeoutId = setTimeout(() => {
      saveWorkingPixelsToFrame();
    }, 500);
    
    return () => clearTimeout(timeoutId);
  }, [workingPixels, saveWorkingPixelsToFrame, playing]);

  const addFrame = useCallback(() => {
    saveWorkingPixelsToFrame();
    pushHistory();
    const newFrames = [...frames];
    const currentDuration = frames[currentFrameIndex].dur;
    newFrames.splice(currentFrameIndex + 1, 0, {
      dur: currentDuration,
      arr: new Array(CANVAS_WIDTH * CANVAS_HEIGHT).fill(false)
    });
    setFrames(newFrames);
    setCurrentFrameIndex(currentFrameIndex + 1);
  }, [frames, currentFrameIndex, pushHistory, saveWorkingPixelsToFrame]);

  const duplicateFrame = useCallback(() => {
    saveWorkingPixelsToFrame();
    pushHistory();
    const newFrames = [...frames];
    newFrames.splice(currentFrameIndex + 1, 0, {
      dur: frames[currentFrameIndex].dur,
      arr: [...workingPixels]
    });
    setFrames(newFrames);
    setCurrentFrameIndex(currentFrameIndex + 1);
  }, [frames, currentFrameIndex, pushHistory, saveWorkingPixelsToFrame, workingPixels]);

  const deleteFrame = useCallback(() => {
    if (frames.length === 1) {
      showAlert('Cannot Delete', 'Cannot delete the last frame!');
      return;
    }
    showConfirm(
      'Delete Frame',
      `Are you sure you want to delete frame ${currentFrameIndex + 1}?`,
      () => {
        pushHistory();
        const newFrames = frames.filter((_, i) => i !== currentFrameIndex);
        setFrames(newFrames);
        const newIndex = Math.min(currentFrameIndex, newFrames.length - 1);
        setCurrentFrameIndex(newIndex);
        setWorkingPixels([...newFrames[newIndex].arr]);
        setFrameDurationSeconds(newFrames[newIndex].dur / 1000);
      },
      'deleteFrame'
    );
  }, [frames, currentFrameIndex, pushHistory, showAlert, showConfirm]);

  const nextFrame = useCallback(() => {
    saveWorkingPixelsToFrame();
    setCurrentFrameIndex((prev) => Math.min(prev + 1, frames.length - 1));
  }, [frames.length, saveWorkingPixelsToFrame]);

  const prevFrame = useCallback(() => {
    saveWorkingPixelsToFrame();
    setCurrentFrameIndex((prev) => Math.max(prev - 1, 0));
  }, [saveWorkingPixelsToFrame]);

  const playingRef = useRef(false);
  
  useEffect(() => {
    playingRef.current = playing;
  }, [playing]);

  const play = useCallback(() => {
    if (playingRef.current) return;
    setPlaying(true);
    
    let currentIndex = currentFrameIndex;
    
    const step = () => {
      if (!playingRef.current) return;
      
      currentIndex = (currentIndex + 1) % framesRef.current.length;
      setCurrentFrameIndex(currentIndex);
      
      playTimerRef.current = setTimeout(step, framesRef.current[currentIndex].dur);
    };
    
    playTimerRef.current = setTimeout(step, framesRef.current[currentIndex].dur);
  }, [currentFrameIndex]);

  const stop = useCallback(() => {
    setPlaying(false);
    if (playTimerRef.current) {
      clearTimeout(playTimerRef.current);
      playTimerRef.current = null;
    }
    setWorkingPixels([...framesRef.current[currentFrameIndex].arr]);
  }, [currentFrameIndex]);

  const togglePlayPause = useCallback(() => {
    if (playingRef.current) {
      stop();
    } else {
      play();
    }
  }, [play, stop]);

  const updateCurrentFramePixels = useCallback((newPixels: boolean[]) => {
    setWorkingPixels(newPixels);
  }, []);

  const displayPixels = useMemo(() => {
    return playing ? frames[currentFrameIndex].arr : workingPixels;
  }, [playing, frames, currentFrameIndex, workingPixels]);

  const updateFrameDuration = useCallback((seconds: number) => {
    setFrameDurationSeconds(seconds);
    const durMs = Math.round(seconds * 1000);
    const newFrames = [...frames];
    newFrames[currentFrameIndex] = { ...newFrames[currentFrameIndex], dur: durMs };
    setFrames(newFrames);
    framesRef.current = newFrames;
  }, [frames, currentFrameIndex]);

  const getOnionSkin = useCallback(() => {
    if (!onionEnabled || currentFrameIndex === 0) return undefined;
    const prevFrame = frames[currentFrameIndex - 1];
    return prevFrame ? prevFrame.arr : undefined;
  }, [onionEnabled, currentFrameIndex, frames]);

  const loadAnimationForEditing = useCallback((animationId: string, animationFrames?: Array<{ dur: number; arr: boolean[] }>) => {
    if (!animationFrames || animationFrames.length === 0) {
      showAlert('No Frames', 'No frames found for this animation');
      return;
    }

    const doLoad = () => {
      // Load the animation
      const savedAnimations = JSON.parse(localStorage.getItem('customAnimations') || '[]');
      const animation = savedAnimations.find((a: { id: string }) => a.id === animationId);
      
      if (animation) {
        setProjectName(animation.name);
        setFrames(animationFrames);
        setCurrentFrameIndex(0);
        setWorkingPixels([...animationFrames[0].arr]);
        setFrameDurationSeconds(animationFrames[0].dur / 1000);
        setHistory([]);
        setHistoryIndex(-1);
        // Mark as saved since we just loaded it
        setLastSavedState(JSON.stringify({ frames: animationFrames, projectName: animation.name }));
        setHasUnsavedChanges(false);
        showAlert('Animation Loaded', `Loaded "${animation.name}" for editing`);
      }
    };

    // Only warn if there are actual unsaved changes
    if (hasUnsavedChanges) {
      showConfirm(
        'Unsaved Changes',
        'Your work isn\'t saved. Are you sure you want to continue?',
        doLoad,
        'loadAnimation'
      );
    } else {
      doLoad();
    }
  }, [hasUnsavedChanges, showAlert, showConfirm]);

  useEffect(() => {
    return () => {
      if (playTimerRef.current) clearTimeout(playTimerRef.current);
    };
  }, []);

  // Calculate equipped animation metadata for sidebar
  const equippedAnimation = useMemo(() => {
    // Check if it's a custom animation first
    const customAnim = customAnimations.find(c => c.id === equippedId);
    if (customAnim) {
      return {
        id: customAnim.id,
        name: customAnim.name,
        description: `Custom animation created on ${new Date(customAnim.createdAt).toLocaleDateString()}`,
        status: customAnim.status as "Available" | "Equiped",
      };
    }
    
    // Otherwise check built-in animations
    const anim = Object.values(animations).find(
      (a) => a.metadata.id === equippedId
    );
    return anim?.metadata;
  }, [equippedId, customAnimations]);

  // Get custom frames for equipped animation if it's custom
  const equippedCustomFrames = useMemo(() => {
    const customAnim = customAnimations.find(c => c.id === equippedId);
    return customAnim?.frames;
  }, [equippedId, customAnimations]);

  // Copy selection to clipboard (only white pixels)
  const copySelection = useCallback(() => {
    if (!selection) return;

    const minX = Math.min(selection.startX, selection.endX);
    const maxX = Math.max(selection.startX, selection.endX);
    const minY = Math.min(selection.startY, selection.endY);
    const maxY = Math.max(selection.startY, selection.endY);
    
    const width = maxX - minX + 1;
    const height = maxY - minY + 1;
    const pixels: boolean[] = [];

    for (let y = minY; y <= maxY; y++) {
      for (let x = minX; x <= maxX; x++) {
        const index = y * CANVAS_WIDTH + x;
        // Only copy white pixels (true values)
        pixels.push(workingPixels[index] === true);
      }
    }

    setClipboard({ width, height, pixels });
  }, [selection, workingPixels]);

  // Paste clipboard at current selection start or center
  const pasteClipboard = useCallback(() => {
    if (!clipboard) return;

    const pasteX = selection ? Math.min(selection.startX, selection.endX) : Math.floor((CANVAS_WIDTH - clipboard.width) / 2);
    const pasteY = selection ? Math.min(selection.startY, selection.endY) : Math.floor((CANVAS_HEIGHT - clipboard.height) / 2);

    const newPixels = [...workingPixels];

    for (let dy = 0; dy < clipboard.height; dy++) {
      for (let dx = 0; dx < clipboard.width; dx++) {
        const targetX = pasteX + dx;
        const targetY = pasteY + dy;
        
        if (targetX >= 0 && targetX < CANVAS_WIDTH && targetY >= 0 && targetY < CANVAS_HEIGHT) {
          const sourceIndex = dy * clipboard.width + dx;
          const targetIndex = targetY * CANVAS_WIDTH + targetX;
          // Only paste white pixels (overwrite only if source pixel is true)
          if (clipboard.pixels[sourceIndex]) {
            newPixels[targetIndex] = true;
          }
        }
      }
    }

    setWorkingPixels(newPixels);
    pushHistory();
    setSelection(null); // Clear selection after paste
  }, [clipboard, selection, workingPixels, pushHistory]);

  // Undo function
  const undo = useCallback(() => {
    if (historyIndex > 0) {
      const prevState = history[historyIndex - 1];
      setFrames(prevState);
      setHistoryIndex(historyIndex - 1);
      setWorkingPixels([...prevState[currentFrameIndex].arr]);
    }
  }, [history, historyIndex, currentFrameIndex]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) {
        return;
      }
      
      const key = e.key.toLowerCase();
      const ctrlOrCmd = e.ctrlKey || e.metaKey;
      
      if (key === ' ') {
        e.preventDefault();
        togglePlayPause();
      } else if (key === 'arrowleft') {
        e.preventDefault();
        prevFrame();
      } else if (key === 'arrowright') {
        e.preventDefault();
        nextFrame();
      } else if (key === 'b') {
        setActiveTool('brush');
        setBrushMode('paint');
      } else if (key === 'x') {
        setActiveTool('brush');
        setBrushMode('erase');
      } else if (key === 'l') {
        setActiveTool('line');
      } else if (key === 'e') {
        setActiveTool('ellipse');
      } else if (key === 'r') {
        setActiveTool('rect');
      } else if (key === 'f') {
        setActiveTool('fill');
      } else if (key === 's') {
        setActiveTool('select');
      } else if (key === '[') {
        setBrushSize(prev => Math.max(1, prev - 1));
      } else if (key === ']') {
        setBrushSize(prev => Math.min(8, prev + 1));
      } else if (ctrlOrCmd && key === 'c' && selection) {
        e.preventDefault();
        copySelection();
      } else if (ctrlOrCmd && key === 'v' && clipboard) {
        e.preventDefault();
        pasteClipboard();
      } else if (ctrlOrCmd && key === 'z') {
        e.preventDefault();
        // Undo: restore previous history state
        if (historyIndex > 0) {
          const prevState = history[historyIndex - 1];
          setFrames(prevState);
          setHistoryIndex(historyIndex - 1);
          setWorkingPixels([...prevState[currentFrameIndex].arr]);
        }
      } else if (key === 'escape' && selection) {
        setSelection(null);
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [togglePlayPause, nextFrame, prevFrame, selection, clipboard, copySelection, pasteClipboard, history, historyIndex, currentFrameIndex]);

  return (
    <div className="flex h-screen bg-background text-foreground">
      <Sidebar
        searchQuery=""
        onSearchChange={() => {}}
        isCollapsed={isSidebarCollapsed}
        onToggleSidebar={() => setIsSidebarCollapsed(!isSidebarCollapsed)}
        favorites={favorites}
        equippedAnimation={equippedAnimation}
        equippedCustomFrames={equippedCustomFrames}
        customAnimations={customAnimations}
      />

      <main className="flex-1 flex flex-col overflow-hidden">
        <div className="shrink-0">
          <Header onToggleSidebar={() => setIsSidebarCollapsed(!isSidebarCollapsed)} />
        </div>

        <div className="flex-1 flex overflow-hidden gap-2 px-6">
          {/* Canvas and timeline - takes remaining space */}
          <div className="flex-1 flex flex-col min-w-0 bg-background pt-4">
            {/* Tool Bar */}
            <div className="bg-background border-2 border-neutral-800 rounded-lg p-3 mb-4">
              <div className="flex items-center gap-2 mb-2">
                <span className="text-neutral-300 text-sm font-medium">Tools</span>
                <div className="flex-1 border-b border-neutral-800"></div>
                <span className="text-neutral-600 text-xs">B • X • L • E • R • F • S {clipboard && "• Ctrl+V"}</span>
              </div>
              <div className="flex items-center gap-2">
                <button
                  onClick={() => {
                    setActiveTool('brush');
                    setBrushMode('paint');
                  }}
                  className={`p-2 rounded-md transition-colors ${
                    brushMode === 'paint'
                      ? 'bg-white text-black'
                      : 'bg-background text-neutral-300 hover:bg-neutral-800'
                  }`}
                  title="Brush (B)"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M7 14c-1.66 0-3 1.34-3 3 0 1.31-1.16 2-2 2 .92 1.22 2.49 2 4 2 2.21 0 4-1.79 4-4 0-1.66-1.34-3-3-3zm13.71-9.37l-1.34-1.34a.996.996 0 0 0-1.41 0L9 12.25 11.75 15l8.96-8.96c.39-.39.39-1.02 0-1.41z"/>
                  </svg>
                </button>
                <button
                  onClick={() => {
                    setActiveTool('brush');
                    setBrushMode('erase');
                  }}
                  className={`p-2 rounded-md transition-colors ${
                    brushMode === 'erase'
                      ? 'bg-white text-black'
                      : 'bg-background text-neutral-300 hover:bg-neutral-800'
                  }`}
                  title="Eraser (X)"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M16.24 3.56l4.95 4.94c.78.79.78 2.05 0 2.84L12 20.53a4.008 4.008 0 0 1-5.66 0L2.81 17c-.78-.79-.78-2.05 0-2.84l10.6-10.6c.79-.78 2.05-.78 2.83 0M4.22 15.58l3.54 3.53c.78.79 2.04.79 2.83 0l3.53-3.53-6.36-6.36-3.54 3.53z"/>
                  </svg>
                </button>
                <div className="w-px h-6 bg-neutral-800 mx-1"></div>
                <button
                  onClick={() => setActiveTool('line')}
                  className={`p-2 rounded-md transition-colors ${
                    activeTool === 'line'
                      ? 'bg-white text-black'
                      : 'bg-background text-neutral-300 hover:bg-neutral-800'
                  }`}
                  title="Line (L)"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <line x1="5" y1="19" x2="19" y2="5"/>
                  </svg>
                </button>
                <button
                  onClick={() => setActiveTool('ellipse')}
                  className={`p-2 rounded-md transition-colors ${
                    activeTool === 'ellipse'
                      ? 'bg-white text-black'
                      : 'bg-background text-neutral-300 hover:bg-neutral-800'
                  }`}
                  title="Ellipse (E)"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <ellipse cx="12" cy="12" rx="7" ry="5"/>
                  </svg>
                </button>
                <button
                  onClick={() => setActiveTool('rect')}
                  className={`p-2 rounded-md transition-colors ${
                    activeTool === 'rect'
                      ? 'bg-white text-black'
                      : 'bg-background text-neutral-300 hover:bg-neutral-800'
                  }`}
                  title="Rectangle (R)"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <rect x="5" y="7" width="14" height="10"/>
                  </svg>
                </button>
                <button
                  onClick={() => setActiveTool('fill')}
                  className={`p-2 rounded-md transition-colors ${
                    activeTool === 'fill'
                      ? 'bg-white text-black'
                      : 'bg-background text-neutral-300 hover:bg-neutral-800'
                  }`}
                  title="Fill (F)"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M16.56 8.94L7.62 0 6.21 1.41l2.38 2.38-5.15 5.15c-.59.59-.59 1.54 0 2.12l5.5 5.5c.29.29.68.44 1.06.44s.77-.15 1.06-.44l5.5-5.5c.59-.58.59-1.53 0-2.12zM5.21 10L10 5.21 14.79 10H5.21zM19 11.5s-2 2.17-2 3.5c0 1.1.9 2 2 2s2-.9 2-2c0-1.33-2-3.5-2-3.5z"/>
                  </svg>
                </button>
                <div className="w-px h-6 bg-neutral-800 mx-1"></div>
                <button
                  onClick={() => setActiveTool('select')}
                  className={`p-2 rounded-md transition-colors ${
                    activeTool === 'select'
                      ? 'bg-white text-black'
                      : 'bg-background text-neutral-300 hover:bg-neutral-800'
                  }`}
                  title="Select (S)"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeDasharray="4 2">
                    <rect x="6" y="6" width="12" height="12"/>
                  </svg>
                </button>
                {selection && (
                  <>
                    <button
                      onClick={copySelection}
                      className="p-2 rounded-md transition-colors bg-background text-neutral-300 hover:bg-neutral-800"
                      title="Copy Selection (Ctrl+C)"
                    >
                      <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <rect x="9" y="9" width="13" height="13" rx="2"/>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/>
                      </svg>
                    </button>
                  </>
                )}
                {clipboard && (
                  <button
                    onClick={pasteClipboard}
                    className="p-2 rounded-md transition-colors bg-background text-neutral-300 hover:bg-neutral-800"
                    title="Paste (Ctrl+V)"
                  >
                    <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                      <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"/>
                      <rect x="8" y="2" width="8" height="4" rx="1"/>
                    </svg>
                  </button>
                )}
                <div className="flex-1"></div>
                <button
                  onClick={undo}
                  disabled={historyIndex <= 0}
                  className={`p-2 rounded-md transition-colors ${
                    historyIndex > 0
                      ? 'bg-background text-neutral-300 hover:bg-neutral-800'
                      : 'bg-background text-neutral-600 cursor-not-allowed'
                  }`}
                  title="Undo (Ctrl+Z)"
                >
                  <svg className="w-5 h-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                    <path d="M3 7v6h6"/>
                    <path d="M21 17a9 9 0 0 0-9-9 9 9 0 0 0-6 2.3L3 13"/>
                  </svg>
                </button>
                <div className="text-neutral-600 text-xs">
                  [ ] Size • Space Play • Ctrl+Z
                </div>
              </div>
            </div>

            {/* Canvas Area */}
            <div className="w-full bg-black border-2 border-neutral-800 rounded-lg overflow-hidden mb-6 p-6 flex items-center justify-center">
              <PixelCanvas
                pixels={displayPixels}
                onPixelsChange={playing ? () => {} : updateCurrentFramePixels}
                brushSize={brushSize}
                brushMode={brushMode}
                brushShape={brushShape}
                activeTool={activeTool}
                onionSkin={getOnionSkin()}
                cellSize={14}
                showGrid={true}
                selection={selection}
                onSelectionChange={setSelection}
                isSelecting={isSelecting}
                onSelectingChange={setIsSelecting}
              />
            </div>

            {/* Frame Timeline */}
            <div className="flex items-center gap-2 mb-4">
              <button
                onClick={() => scroll('left')}
                disabled={!canScrollLeft}
                className={`shrink-0 p-1.5 rounded-lg transition-colors ${
                  canScrollLeft
                    ? 'bg-neutral-800 hover:bg-neutral-700 text-white'
                    : 'bg-neutral-900 text-neutral-600 cursor-not-allowed'
                }`}
              >
                <ChevronLeft size={18} />
              </button>

              <div
                ref={scrollContainerRef}
                className="flex-1 overflow-x-auto scrollbar-hide flex gap-2"
                style={{ scrollBehavior: 'smooth' }}
              >
                {frames.map((frame, i) => (
                  <div key={i} className="flex items-center shrink-0">
                    <FrameThumbnail
                      frame={frame}
                      index={i}
                      isActive={i === currentFrameIndex}
                      onClick={() => {
                        if (i !== currentFrameIndex) {
                          saveWorkingPixelsToFrame();
                          setCurrentFrameIndex(i);
                        }
                      }}
                    />
                    {i < frames.length - 1 && (
                      <div className="flex flex-col gap-0.5 mx-1.5 shrink-0">
                        <div className="w-0.5 h-1 bg-neutral-800"></div>
                        <div className="w-0.5 h-1 bg-neutral-800"></div>
                        <div className="w-0.5 h-1 bg-neutral-800"></div>
                      </div>
                    )}
                  </div>
                ))}
              </div>

              <button
                onClick={() => scroll('right')}
                disabled={!canScrollRight}
                className={`shrink-0 p-1.5 rounded-lg transition-colors ${
                  canScrollRight
                    ? 'bg-neutral-800 hover:bg-neutral-700 text-white'
                    : 'bg-neutral-900 text-neutral-600 cursor-not-allowed'
                }`}
              >
                <ChevronRight size={18} />
              </button>
            </div>
          </div>

          {/* Control Panel - fixed width */}
          <div className="w-60 shrink-0 bg-background pt-4 pl-3 space-y-4">
            {/* Project Name */}
            <div className="relative">
              <input
                type="text"
                value={projectName}
                onChange={(e) => setProjectName(e.target.value)}
                className="w-full bg-background border-2 border-neutral-700 rounded-lg px-3 py-2 text-neutral-400 placeholder-neutral-600 focus:outline-none focus:border-neutral-500 text-center text-xs"
                placeholder="Untitled"
              />
              {hasUnsavedChanges && (
                <div className="absolute right-2 top-1/2 -translate-y-1/2 text-yellow-500 text-xs font-bold" title="Unsaved changes">
                  *
                </div>
              )}
            </div>

            {/* Create New and Save */}
            <div className="flex gap-2">
              <button
                onClick={() => {
                  const doCreateNew = () => {
                    setFrames([{ dur: 1000, arr: new Array(CANVAS_WIDTH * CANVAS_HEIGHT).fill(false) }]);
                    setCurrentFrameIndex(0);
                    setProjectName("Untitled");
                    setFrameDurationSeconds(1);
                    setWorkingPixels(new Array(CANVAS_WIDTH * CANVAS_HEIGHT).fill(false));
                    setHistory([]);
                    setHistoryIndex(-1);
                    // Reset saved state
                    const newState = JSON.stringify({ 
                      frames: [{ dur: 1000, arr: new Array(CANVAS_WIDTH * CANVAS_HEIGHT).fill(false) }], 
                      projectName: "Untitled" 
                    });
                    setLastSavedState(newState);
                    setHasUnsavedChanges(false);
                  };

                  // Only warn if there are unsaved changes
                  if (hasUnsavedChanges) {
                    showConfirm(
                      'Unsaved Changes',
                      'Your work isn\'t saved. Are you sure you want to continue?',
                      doCreateNew,
                      'createNew'
                    );
                  } else {
                    doCreateNew();
                  }
                }}
                className="flex-1 bg-background border-2 border-neutral-700 rounded-lg px-3 py-1.5 text-neutral-300 hover:border-neutral-500 transition-colors text-xs"
              >
                Create New
              </button>
              <button
                onClick={async () => {
                  if (!projectName || projectName.trim() === "" || projectName === "Untitled") {
                    showAlert('Invalid Name', 'Please enter a valid project name!');
                    return;
                  }
                  
                  const doSave = async () => {
                    saveWorkingPixelsToFrame();
                  
                    try {
                      // Save to localStorage
                      const savedAnimations = JSON.parse(localStorage.getItem('customAnimations') || '[]');
                      const animationData = {
                        id: `custom-${Date.now()}`,
                        name: projectName,
                        frames: frames,
                        createdAt: new Date().toISOString(),
                        status: 'Custom'
                      };
                      
                      // Check if animation with same name exists
                      const existingIndex = savedAnimations.findIndex((a: { name: string }) => a.name === projectName);
                      if (existingIndex >= 0) {
                        savedAnimations[existingIndex] = animationData;
                      } else {
                        savedAnimations.push(animationData);
                      }
                      
                      localStorage.setItem('customAnimations', JSON.stringify(savedAnimations));
                      
                      // Trigger event to update library
                      window.dispatchEvent(new Event('customAnimationsUpdated'));
                      
                      // Mark as saved
                      const savedState = JSON.stringify({ frames, projectName });
                      setLastSavedState(savedState);
                      setHasUnsavedChanges(false);
                      
                      showAlert('Success', 'Animation saved successfully! Go to Library to see it.');
                    } catch (error) {
                      console.error('Failed to save animation:', error);
                      showAlert('Error', 'Failed to save animation. Please try again.');
                    }
                  };

                  showConfirm(
                    'Save Animation',
                    `Are you sure you want to save "${projectName}"?`,
                    doSave,
                    'saveAnimation'
                  );
                }}
                className="flex-1 bg-background border-2 border-neutral-700 rounded-lg px-3 py-1.5 text-neutral-300 hover:border-neutral-500 transition-colors flex items-center justify-center gap-1 text-xs"
              >
                <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 16v6m0 0h16m-16 0v-6m16 6v-6m0 0V4" />
                </svg>
                Save
              </button>
            </div>

            {/* Play Button */}
            <button
              onClick={togglePlayPause}
              className="w-full bg-background border-2 border-neutral-700 rounded-lg px-3 py-1.5 text-neutral-300 hover:border-neutral-500 transition-colors flex items-center justify-center gap-1 text-xs"
            >
              {playing ? 'Pause' : 'Play'}
              <svg className="w-4 h-4 fill-current" viewBox="0 0 24 24">
                {playing ? (
                  <>
                    <rect x="6" y="4" width="4" height="16" />
                    <rect x="14" y="4" width="4" height="16" />
                  </>
                ) : (
                  <polygon points="5 3 19 12 5 21" />
                )}
              </svg>
            </button>

            {/* Add Frame and Duplicate */}
            <div className="flex gap-2">
              <button
                onClick={addFrame}
                className="flex-1 bg-background border-2 border-neutral-700 rounded-lg px-2 py-1.5 text-neutral-300 hover:border-neutral-500 transition-colors flex items-center justify-center gap-1 text-xs"
              >
                <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 4v16m8-8H4" />
                </svg>
                Add Frame
              </button>
              <button
                onClick={duplicateFrame}
                className="flex-1 bg-background border-2 border-neutral-700 rounded-lg px-2 py-1.5 text-neutral-300 hover:border-neutral-500 transition-colors flex items-center justify-center gap-1 text-xs"
              >
                <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                </svg>
                Duplicate
              </button>
            </div>

            {/* Size Slider */}
            <div className="space-y-1.5">
              <label className="block text-neutral-300 text-xs font-medium">Size</label>
              <div className="flex items-center gap-3">
                <input
                  type="range"
                  min="1"
                  max="8"
                  value={brushSize}
                  onChange={(e) => setBrushSize(parseInt(e.target.value))}
                  className="flex-1 h-1 bg-neutral-700 rounded-lg appearance-none cursor-pointer accent-white"
                />
                <span className="text-neutral-300 text-xs w-4">{brushSize}</span>
              </div>
            </div>

            {/* Brush Type */}
            <div className="space-y-2">
              <label className="block text-neutral-300 text-xs font-medium">Brush Type</label>
              <div className="grid grid-cols-3 gap-1.5">
                <button
                  onClick={() => setBrushShape('square')}
                  className={`aspect-square rounded-lg border-2 transition-colors ${
                    brushShape === 'square'
                      ? 'border-neutral-400 bg-neutral-900'
                      : 'border-neutral-700 bg-black hover:border-neutral-600'
                  } flex items-center justify-center`}
                >
                  <svg className="w-6 h-6" viewBox="0 0 24 24" fill="white">
                    <rect x="6" y="6" width="12" height="12" />
                  </svg>
                </button>
                <button
                  onClick={() => setBrushShape('circle')}
                  className={`aspect-square rounded-lg border-2 transition-colors ${
                    brushShape === 'circle'
                      ? 'border-neutral-400 bg-neutral-900'
                      : 'border-neutral-700 bg-black hover:border-neutral-600'
                  } flex items-center justify-center`}
                >
                  <svg className="w-6 h-6" viewBox="0 0 24 24" fill="white">
                    <circle cx="12" cy="12" r="6" />
                  </svg>
                </button>
                <button
                  onClick={() => setBrushShape('triangle')}
                  className={`aspect-square rounded-lg border-2 transition-colors ${
                    brushShape === 'triangle'
                      ? 'border-neutral-400 bg-neutral-900'
                      : 'border-neutral-700 bg-black hover:border-neutral-600'
                  } flex items-center justify-center`}
                >
                  <svg className="w-6 h-6" viewBox="0 0 24 24" fill="white">
                    <polygon points="12,6 18,18 6,18" />
                  </svg>
                </button>
              </div>
            </div>

            {/* Onion Skin */}
            <div className="flex items-center justify-between">
              <label className="text-neutral-300 text-xs font-medium">Onion Skin</label>
              <input
                type="checkbox"
                checked={onionEnabled}
                onChange={(e) => setOnionEnabled(e.target.checked)}
                className="w-4 h-4 rounded bg-background border-2 border-neutral-600 cursor-pointer accent-white"
              />
            </div>

            {/* Frame Info */}
            <div className="text-center text-neutral-300 text-sm py-2">
              Frame {currentFrameIndex + 1} / {frames.length}
            </div>

            {/* Next/Prev Frame */}
            <div className="flex gap-2">
              <button 
                onClick={prevFrame}
                className="flex-1 bg-background border-2 border-neutral-700 rounded-lg px-2 py-1.5 text-neutral-300 hover:border-neutral-500 transition-colors flex items-center justify-center gap-1 text-xs"
              >
                <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" />
                </svg>
                Prev
              </button>
              <button 
                onClick={nextFrame}
                className="flex-1 bg-background border-2 border-neutral-700 rounded-lg px-2 py-1.5 text-neutral-300 hover:border-neutral-500 transition-colors flex items-center justify-center gap-1 text-xs"
              >
                Next
                <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
                </svg>
              </button>
            </div>

            {/* Frame Duration */}
            <div className="flex items-center justify-between">
              <label className="text-neutral-300 text-xs font-medium">Frame Duration</label>
              <div className="flex items-center bg-background border-2 border-neutral-700 rounded-lg px-2 py-1">
                <input
                  type="number"
                  value={frameDurationSeconds}
                  onChange={(e) => updateFrameDuration(parseFloat(e.target.value) || 0.1)}
                  min="0.1"
                  max="10"
                  step="0.1"
                  className="w-14 bg-transparent text-neutral-300 text-xs focus:outline-none text-right"
                />
                <span className="text-neutral-500 text-xs ml-1">sec</span>
              </div>
            </div>

            {/* Remove Frame */}
            <button
              onClick={deleteFrame}
              className="w-full bg-background border-2 border-neutral-700 rounded-lg px-3 py-1.5 text-neutral-300 hover:border-neutral-500 transition-colors flex items-center justify-center gap-1 text-xs"
            >
              <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3H4a1 1 0 000 2h1.05L5 19a3 3 0 003 3h8a3 3 0 003-3l.95-12H20a1 1 0 100-2h-3z" />
              </svg>
              Remove Frame
            </button>

            {/* Reset Dialog Preferences */}
            {skipDialogs.size > 0 && (
              <button
                onClick={() => {
                  setSkipDialogs(new Set());
                  localStorage.removeItem('skipDialogs');
                  showAlert('Preferences Reset', 'All "Don\'t show again" preferences have been reset.');
                }}
                className="w-full bg-background border-2 border-neutral-700 rounded-lg px-3 py-1.5 text-neutral-400 hover:border-neutral-500 hover:text-neutral-300 transition-colors flex items-center justify-center gap-1 text-xs"
                title="Reset all 'Don't show again' preferences"
              >
                <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                Reset Dialogs
              </button>
            )}
          </div>
        </div>

        {/* Latest Animations at bottom */}
        <div className="shrink-0 border-t border-border bg-background">
          <LatestAnimations
            onAnimationSelect={loadAnimationForEditing}
            onMenuClick={(id) => console.log('Menu clicked:', id)}
          />
        </div>
      </main>

      <style>{`
        .scrollbar-hide::-webkit-scrollbar {
          display: none;
        }
        .scrollbar-hide {
          -ms-overflow-style: none;
          scrollbar-width: none;
        }
      `}</style>

      {/* Modal */}
      <Modal
        isOpen={modalConfig.isOpen}
        onClose={closeModal}
        onConfirm={modalConfig.onConfirm}
        title={modalConfig.title}
        message={modalConfig.message}
        type={modalConfig.type}
        confirmText={modalConfig.confirmText}
        cancelText={modalConfig.cancelText}
        showDontShowAgain={modalConfig.showDontShowAgain}
        onDontShowAgain={handleDontShowAgain}
      />
    </div>
  );
}
